package stages

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/bitswalk/ldf/src/ldfd/build"
)

// SecuritySetup defines the interface for security framework setup
type SecuritySetup interface {
	// Name returns the security framework name
	Name() string
	// Install installs the security framework files
	Install(rootfsPath string, component *build.ResolvedComponent) error
	// Configure configures the security framework
	Configure(rootfsPath string) error
	// GetKernelParams returns kernel command line parameters for this framework
	GetKernelParams() string
}

// SELinuxSetup configures SELinux
type SELinuxSetup struct{}

// NewSELinuxSetup creates a new SELinux setup
func NewSELinuxSetup() *SELinuxSetup {
	return &SELinuxSetup{}
}

// Name returns the security framework name
func (s *SELinuxSetup) Name() string {
	return "selinux"
}

// Install installs SELinux files
func (s *SELinuxSetup) Install(rootfsPath string, component *build.ResolvedComponent) error {
	// Create SELinux directories
	dirs := []string{
		"/etc/selinux",
		"/etc/selinux/targeted",
		"/etc/selinux/targeted/policy",
		"/etc/selinux/targeted/contexts",
		"/etc/selinux/targeted/contexts/files",
		"/etc/selinux/targeted/contexts/users",
		"/etc/selinux/targeted/modules",
		"/etc/selinux/targeted/modules/active",
		"/var/lib/selinux",
		"/var/lib/selinux/targeted",
	}

	for _, dir := range dirs {
		fullPath := filepath.Join(rootfsPath, dir)
		if err := os.MkdirAll(fullPath, 0755); err != nil {
			return fmt.Errorf("failed to create SELinux directory %s: %w", dir, err)
		}
	}

	// If component has extracted source, copy files
	if component != nil && component.LocalPath != "" {
		log.Info("Installing SELinux from source", "path", component.LocalPath)
	}

	log.Info("Installed SELinux structure")
	return nil
}

// Configure configures SELinux
func (s *SELinuxSetup) Configure(rootfsPath string) error {
	// Create main SELinux config
	selinuxConfig := `# SELinux configuration
# Generated by Linux Distribution Factory

# SELINUX can take one of these values:
#     enforcing - SELinux security policy is enforced
#     permissive - SELinux prints warnings instead of enforcing
#     disabled - No SELinux policy is loaded
SELINUX=permissive

# SELINUXTYPE can take one of these values:
#     targeted - Targeted processes are protected
#     minimum - Modification of targeted policy
#     mls - Multi Level Security protection
SELINUXTYPE=targeted
`
	configPath := filepath.Join(rootfsPath, "etc", "selinux", "config")
	if err := os.WriteFile(configPath, []byte(selinuxConfig), 0644); err != nil {
		return fmt.Errorf("failed to write SELinux config: %w", err)
	}

	// Create targeted policy config
	targetedConfig := `# Targeted policy configuration
policy_version = 33
`
	targetedPath := filepath.Join(rootfsPath, "etc", "selinux", "targeted", "setrans.conf")
	if err := os.WriteFile(targetedPath, []byte(targetedConfig), 0644); err != nil {
		return fmt.Errorf("failed to write targeted config: %w", err)
	}

	// Create seusers file
	seusers := `# SELinux user mapping
__default__:unconfined_u:s0-s0:c0.c1023
root:unconfined_u:s0-s0:c0.c1023
`
	seusersPath := filepath.Join(rootfsPath, "etc", "selinux", "targeted", "seusers")
	if err := os.WriteFile(seusersPath, []byte(seusers), 0644); err != nil {
		return fmt.Errorf("failed to write seusers: %w", err)
	}

	// Create file_contexts placeholder
	fileContexts := `# SELinux file contexts
# This file needs to be populated with proper contexts
/.*     system_u:object_r:default_t:s0
`
	fcPath := filepath.Join(rootfsPath, "etc", "selinux", "targeted", "contexts", "files", "file_contexts")
	if err := os.WriteFile(fcPath, []byte(fileContexts), 0644); err != nil {
		return fmt.Errorf("failed to write file_contexts: %w", err)
	}

	log.Info("Configured SELinux")
	return nil
}

// GetKernelParams returns SELinux kernel parameters
func (s *SELinuxSetup) GetKernelParams() string {
	return "selinux=1 security=selinux"
}

// AppArmorSetup configures AppArmor
type AppArmorSetup struct{}

// NewAppArmorSetup creates a new AppArmor setup
func NewAppArmorSetup() *AppArmorSetup {
	return &AppArmorSetup{}
}

// Name returns the security framework name
func (a *AppArmorSetup) Name() string {
	return "apparmor"
}

// Install installs AppArmor files
func (a *AppArmorSetup) Install(rootfsPath string, component *build.ResolvedComponent) error {
	// Create AppArmor directories
	dirs := []string{
		"/etc/apparmor",
		"/etc/apparmor.d",
		"/etc/apparmor.d/abstractions",
		"/etc/apparmor.d/cache",
		"/etc/apparmor.d/disable",
		"/etc/apparmor.d/force-complain",
		"/etc/apparmor.d/local",
		"/etc/apparmor.d/tunables",
		"/var/lib/apparmor",
		"/var/lib/apparmor/profiles",
	}

	for _, dir := range dirs {
		fullPath := filepath.Join(rootfsPath, dir)
		if err := os.MkdirAll(fullPath, 0755); err != nil {
			return fmt.Errorf("failed to create AppArmor directory %s: %w", dir, err)
		}
	}

	// If component has extracted source, copy files
	if component != nil && component.LocalPath != "" {
		log.Info("Installing AppArmor from source", "path", component.LocalPath)
	}

	log.Info("Installed AppArmor structure")
	return nil
}

// Configure configures AppArmor
func (a *AppArmorSetup) Configure(rootfsPath string) error {
	// Create main AppArmor config
	apparmorConfig := `# AppArmor configuration
# Generated by Linux Distribution Factory

# Enable AppArmor
APPARMOR_ENABLE=yes

# Write cache for faster loading
APPARMOR_WRITE_CACHE=yes

# Enable additional profiling features
APPARMOR_ADDITIONAL_PROFILING=no
`
	configPath := filepath.Join(rootfsPath, "etc", "apparmor", "parser.conf")
	if err := os.WriteFile(configPath, []byte(apparmorConfig), 0644); err != nil {
		return fmt.Errorf("failed to write AppArmor config: %w", err)
	}

	// Create tunables/global
	tunablesGlobal := `# AppArmor global tunables
@{HOME}=@{HOMEDIRS}/*/ /root/
@{HOMEDIRS}=/home/
@{PROC}=/proc/
@{SYS}=/sys/
@{RUN}=/run/ /var/run/
`
	tunablesPath := filepath.Join(rootfsPath, "etc", "apparmor.d", "tunables", "global")
	if err := os.WriteFile(tunablesPath, []byte(tunablesGlobal), 0644); err != nil {
		return fmt.Errorf("failed to write tunables: %w", err)
	}

	// Create base abstraction
	abstractionBase := `# AppArmor base abstraction
  /etc/ld.so.cache r,
  /etc/ld.so.conf r,
  /etc/ld.so.conf.d/ r,
  /etc/ld.so.conf.d/* r,

  /lib{,32,64}/**  mr,
  /usr/lib{,32,64}/** mr,

  /dev/null rw,
  /dev/zero rw,
  /dev/urandom r,

  @{PROC}/sys/kernel/random/uuid r,
`
	basePath := filepath.Join(rootfsPath, "etc", "apparmor.d", "abstractions", "base")
	if err := os.WriteFile(basePath, []byte(abstractionBase), 0644); err != nil {
		return fmt.Errorf("failed to write base abstraction: %w", err)
	}

	log.Info("Configured AppArmor")
	return nil
}

// GetKernelParams returns AppArmor kernel parameters
func (a *AppArmorSetup) GetKernelParams() string {
	return "apparmor=1 security=apparmor"
}

// NoSecuritySetup is a no-op security setup
type NoSecuritySetup struct{}

// NewNoSecuritySetup creates a no-op security setup
func NewNoSecuritySetup() *NoSecuritySetup {
	return &NoSecuritySetup{}
}

// Name returns the security framework name
func (n *NoSecuritySetup) Name() string {
	return "none"
}

// Install does nothing
func (n *NoSecuritySetup) Install(rootfsPath string, component *build.ResolvedComponent) error {
	log.Info("No security framework selected")
	return nil
}

// Configure does nothing
func (n *NoSecuritySetup) Configure(rootfsPath string) error {
	return nil
}

// GetKernelParams returns empty string
func (n *NoSecuritySetup) GetKernelParams() string {
	return ""
}

// GetSecuritySetup returns the appropriate security setup for the config
func GetSecuritySetup(securitySystem string) SecuritySetup {
	switch strings.ToLower(securitySystem) {
	case "selinux":
		return NewSELinuxSetup()
	case "apparmor":
		return NewAppArmorSetup()
	case "none", "":
		return NewNoSecuritySetup()
	default:
		return NewNoSecuritySetup()
	}
}
