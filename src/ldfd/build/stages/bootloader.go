package stages

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/bitswalk/ldf/src/ldfd/build"
	"github.com/bitswalk/ldf/src/ldfd/db"
)

// BootloaderInstaller defines the interface for bootloader installers
type BootloaderInstaller interface {
	// Name returns the bootloader name
	Name() string
	// Install installs the bootloader files to the rootfs
	Install(rootfsPath string, component *build.ResolvedComponent) error
	// Configure generates bootloader configuration
	Configure(rootfsPath string, kernelVersion string, arch db.TargetArch, initramfs bool) error
	// GetInstallCommands returns commands to install bootloader to disk (run during image creation)
	GetInstallCommands(devicePath string, arch db.TargetArch) []string
}

// GRUB2Installer installs and configures GRUB2
type GRUB2Installer struct {
	timeout     int
	distName    string
	distVersion string
}

// NewGRUB2Installer creates a new GRUB2 installer
func NewGRUB2Installer(distName, distVersion string) *GRUB2Installer {
	return &GRUB2Installer{
		timeout:     5,
		distName:    distName,
		distVersion: distVersion,
	}
}

// Name returns the bootloader name
func (i *GRUB2Installer) Name() string {
	return "grub2"
}

// Install installs GRUB2 to the rootfs
func (i *GRUB2Installer) Install(rootfsPath string, component *build.ResolvedComponent) error {
	// Create GRUB directories
	dirs := []string{
		"/boot/grub",
		"/boot/grub/fonts",
		"/boot/grub/locale",
		"/boot/grub/themes",
		"/etc/default",
	}

	for _, dir := range dirs {
		fullPath := filepath.Join(rootfsPath, dir)
		if err := os.MkdirAll(fullPath, 0755); err != nil {
			return fmt.Errorf("failed to create GRUB directory %s: %w", dir, err)
		}
	}

	// Create /etc/default/grub
	grubDefault := fmt.Sprintf(`# GRUB boot loader configuration
# Generated by Linux Distribution Factory

GRUB_DEFAULT=0
GRUB_TIMEOUT=%d
GRUB_DISTRIBUTOR="%s"
GRUB_CMDLINE_LINUX_DEFAULT="quiet"
GRUB_CMDLINE_LINUX=""
GRUB_TERMINAL_INPUT="console"
GRUB_TERMINAL_OUTPUT="console"
GRUB_GFXMODE=auto
GRUB_GFXPAYLOAD_LINUX=keep
`, i.timeout, i.distName)

	grubDefaultPath := filepath.Join(rootfsPath, "etc", "default", "grub")
	if err := os.WriteFile(grubDefaultPath, []byte(grubDefault), 0644); err != nil {
		return fmt.Errorf("failed to write GRUB default config: %w", err)
	}

	// If component has extracted source, copy files
	if component != nil && component.LocalPath != "" {
		log.Info("Installing GRUB2 from source", "path", component.LocalPath)
	}

	log.Info("Installed GRUB2 structure")
	return nil
}

// Configure generates GRUB configuration
func (i *GRUB2Installer) Configure(rootfsPath string, kernelVersion string, arch db.TargetArch, initramfs bool) error {
	// Generate grub.cfg
	var initrdLine string
	if initramfs {
		initrdLine = "\n\tinitrd /boot/initramfs.img"
	}

	grubCfg := fmt.Sprintf(`# GRUB configuration
# Generated by Linux Distribution Factory

set timeout=%d
set default=0

# Load modules
insmod part_gpt
insmod part_msdos
insmod ext2

# Set root
search --no-floppy --fs-uuid --set=root ROOT_UUID

menuentry "%s %s" {
	linux /boot/vmlinuz root=UUID=ROOT_UUID ro quiet%s
}

menuentry "%s %s (recovery mode)" {
	linux /boot/vmlinuz root=UUID=ROOT_UUID ro single%s
}
`, i.timeout, i.distName, i.distVersion, initrdLine, i.distName, i.distVersion, initrdLine)

	grubCfgPath := filepath.Join(rootfsPath, "boot", "grub", "grub.cfg")
	if err := os.WriteFile(grubCfgPath, []byte(grubCfg), 0644); err != nil {
		return fmt.Errorf("failed to write grub.cfg: %w", err)
	}

	log.Info("Configured GRUB2", "kernel", kernelVersion)
	return nil
}

// GetInstallCommands returns commands to install GRUB to disk
func (i *GRUB2Installer) GetInstallCommands(devicePath string, arch db.TargetArch) []string {
	var target string
	switch arch {
	case db.ArchX86_64:
		target = "x86_64-efi"
	case db.ArchAARCH64:
		target = "arm64-efi"
	default:
		target = "i386-pc"
	}

	return []string{
		fmt.Sprintf("grub-install --target=%s --efi-directory=/boot/efi --bootloader-id=LDF %s", target, devicePath),
		"grub-mkconfig -o /boot/grub/grub.cfg",
	}
}

// SystemdBootInstaller installs and configures systemd-boot
type SystemdBootInstaller struct {
	timeout     int
	distName    string
	distVersion string
}

// NewSystemdBootInstaller creates a new systemd-boot installer
func NewSystemdBootInstaller(distName, distVersion string) *SystemdBootInstaller {
	return &SystemdBootInstaller{
		timeout:     5,
		distName:    distName,
		distVersion: distVersion,
	}
}

// Name returns the bootloader name
func (i *SystemdBootInstaller) Name() string {
	return "systemd-boot"
}

// Install installs systemd-boot to the rootfs
func (i *SystemdBootInstaller) Install(rootfsPath string, component *build.ResolvedComponent) error {
	dirs := []string{
		"/boot/efi",
		"/boot/efi/EFI",
		"/boot/efi/EFI/BOOT",
		"/boot/efi/EFI/Linux",
		"/boot/efi/loader",
		"/boot/efi/loader/entries",
	}

	for _, dir := range dirs {
		fullPath := filepath.Join(rootfsPath, dir)
		if err := os.MkdirAll(fullPath, 0755); err != nil {
			return fmt.Errorf("failed to create EFI directory %s: %w", dir, err)
		}
	}

	log.Info("Installed systemd-boot structure")
	return nil
}

// Configure generates systemd-boot configuration
func (i *SystemdBootInstaller) Configure(rootfsPath string, kernelVersion string, arch db.TargetArch, initramfs bool) error {
	loaderConf := fmt.Sprintf(`default %s.conf
timeout %d
console-mode max
editor no
`, strings.ToLower(i.distName), i.timeout)

	loaderPath := filepath.Join(rootfsPath, "boot", "efi", "loader", "loader.conf")
	if err := os.WriteFile(loaderPath, []byte(loaderConf), 0644); err != nil {
		return fmt.Errorf("failed to write loader.conf: %w", err)
	}

	var initrdLine string
	if initramfs {
		initrdLine = "\ninitrd /initramfs.img"
	}

	entryConf := fmt.Sprintf(`title %s %s
version %s
linux /vmlinuz
options root=UUID=ROOT_UUID ro quiet%s
`, i.distName, i.distVersion, kernelVersion, initrdLine)

	entryPath := filepath.Join(rootfsPath, "boot", "efi", "loader", "entries", strings.ToLower(i.distName)+".conf")
	if err := os.WriteFile(entryPath, []byte(entryConf), 0644); err != nil {
		return fmt.Errorf("failed to write boot entry: %w", err)
	}

	recoveryConf := fmt.Sprintf(`title %s %s (recovery)
version %s
linux /vmlinuz
options root=UUID=ROOT_UUID ro single%s
`, i.distName, i.distVersion, kernelVersion, initrdLine)

	recoveryPath := filepath.Join(rootfsPath, "boot", "efi", "loader", "entries", strings.ToLower(i.distName)+"-recovery.conf")
	if err := os.WriteFile(recoveryPath, []byte(recoveryConf), 0644); err != nil {
		return fmt.Errorf("failed to write recovery entry: %w", err)
	}

	log.Info("Configured systemd-boot", "kernel", kernelVersion)
	return nil
}

// GetInstallCommands returns commands to install systemd-boot to disk
func (i *SystemdBootInstaller) GetInstallCommands(devicePath string, arch db.TargetArch) []string {
	return []string{
		"bootctl --path=/boot/efi install",
	}
}

// UKIInstaller creates Unified Kernel Images
type UKIInstaller struct {
	distName    string
	distVersion string
}

// NewUKIInstaller creates a new UKI installer
func NewUKIInstaller(distName, distVersion string) *UKIInstaller {
	return &UKIInstaller{
		distName:    distName,
		distVersion: distVersion,
	}
}

// Name returns the bootloader name
func (i *UKIInstaller) Name() string {
	return "uki"
}

// Install installs UKI structure to the rootfs
func (i *UKIInstaller) Install(rootfsPath string, component *build.ResolvedComponent) error {
	dirs := []string{
		"/boot/efi",
		"/boot/efi/EFI",
		"/boot/efi/EFI/BOOT",
		"/boot/efi/EFI/Linux",
	}

	for _, dir := range dirs {
		fullPath := filepath.Join(rootfsPath, dir)
		if err := os.MkdirAll(fullPath, 0755); err != nil {
			return fmt.Errorf("failed to create EFI directory %s: %w", dir, err)
		}
	}

	log.Info("Installed UKI structure")
	return nil
}

// Configure creates the UKI configuration
func (i *UKIInstaller) Configure(rootfsPath string, kernelVersion string, arch db.TargetArch, initramfs bool) error {
	cmdline := "root=UUID=ROOT_UUID ro quiet\n"
	cmdlinePath := filepath.Join(rootfsPath, "etc", "kernel", "cmdline")
	if err := os.MkdirAll(filepath.Dir(cmdlinePath), 0755); err != nil {
		return err
	}
	if err := os.WriteFile(cmdlinePath, []byte(cmdline), 0644); err != nil {
		return fmt.Errorf("failed to write cmdline: %w", err)
	}

	log.Info("Configured UKI", "kernel", kernelVersion)
	return nil
}

// GetInstallCommands returns commands to create and install UKI
func (i *UKIInstaller) GetInstallCommands(devicePath string, arch db.TargetArch) []string {
	ukiName := fmt.Sprintf("%s-%s.efi", strings.ToLower(i.distName), i.distVersion)

	return []string{
		fmt.Sprintf("ukify build --linux=/boot/vmlinuz --initrd=/boot/initramfs.img --cmdline=@/etc/kernel/cmdline --output=/boot/efi/EFI/Linux/%s", ukiName),
	}
}

// GetBootloaderInstaller returns the appropriate bootloader installer for the config
func GetBootloaderInstaller(bootloader, distName, distVersion string) BootloaderInstaller {
	switch strings.ToLower(bootloader) {
	case "grub", "grub2":
		return NewGRUB2Installer(distName, distVersion)
	case "systemd-boot", "sd-boot":
		return NewSystemdBootInstaller(distName, distVersion)
	case "uki":
		return NewUKIInstaller(distName, distVersion)
	default:
		return NewGRUB2Installer(distName, distVersion)
	}
}
