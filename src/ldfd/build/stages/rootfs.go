package stages

import (
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"

	"github.com/bitswalk/ldf/src/common/logs"
	"github.com/bitswalk/ldf/src/ldfd/db"
)

var log = logs.NewDefault()

// RootfsBuilder handles root filesystem assembly operations
type RootfsBuilder struct {
	rootfsPath  string
	config      *db.DistributionConfig
	distName    string
	distVersion string
}

// NewRootfsBuilder creates a new rootfs builder
func NewRootfsBuilder(rootfsPath, distName, distVersion string, config *db.DistributionConfig) *RootfsBuilder {
	return &RootfsBuilder{
		rootfsPath:  rootfsPath,
		config:      config,
		distName:    distName,
		distVersion: distVersion,
	}
}

// CreateSkeleton creates the FHS directory structure
func (b *RootfsBuilder) CreateSkeleton() error {
	// FHS 3.0 compliant directory structure
	dirs := []struct {
		path string
		mode os.FileMode
	}{
		// Root directories
		{"/bin", 0755},
		{"/boot", 0755},
		{"/dev", 0755},
		{"/etc", 0755},
		{"/home", 0755},
		{"/lib", 0755},
		{"/lib64", 0755},
		{"/media", 0755},
		{"/mnt", 0755},
		{"/opt", 0755},
		{"/proc", 0555},
		{"/root", 0700},
		{"/run", 0755},
		{"/sbin", 0755},
		{"/srv", 0755},
		{"/sys", 0555},
		{"/tmp", 01777},
		{"/usr", 0755},
		{"/var", 0755},

		// /etc subdirectories
		{"/etc/default", 0755},
		{"/etc/opt", 0755},
		{"/etc/sysconfig", 0755},
		{"/etc/network", 0755},
		{"/etc/ssl", 0755},
		{"/etc/ssl/certs", 0755},
		{"/etc/ssl/private", 0700},

		// /usr subdirectories
		{"/usr/bin", 0755},
		{"/usr/include", 0755},
		{"/usr/lib", 0755},
		{"/usr/lib64", 0755},
		{"/usr/libexec", 0755},
		{"/usr/local", 0755},
		{"/usr/local/bin", 0755},
		{"/usr/local/etc", 0755},
		{"/usr/local/include", 0755},
		{"/usr/local/lib", 0755},
		{"/usr/local/sbin", 0755},
		{"/usr/local/share", 0755},
		{"/usr/local/src", 0755},
		{"/usr/sbin", 0755},
		{"/usr/share", 0755},
		{"/usr/share/doc", 0755},
		{"/usr/share/man", 0755},
		{"/usr/share/misc", 0755},
		{"/usr/src", 0755},

		// /var subdirectories
		{"/var/cache", 0755},
		{"/var/lib", 0755},
		{"/var/local", 0755},
		{"/var/lock", 0755},
		{"/var/log", 0755},
		{"/var/mail", 0755},
		{"/var/opt", 0755},
		{"/var/run", 0755},
		{"/var/spool", 0755},
		{"/var/spool/cron", 0755},
		{"/var/spool/mail", 0755},
		{"/var/tmp", 01777},
	}

	for _, d := range dirs {
		fullPath := filepath.Join(b.rootfsPath, d.path)
		if err := os.MkdirAll(fullPath, d.mode); err != nil {
			return fmt.Errorf("failed to create directory %s: %w", d.path, err)
		}
		// Set mode explicitly in case directory existed
		if err := os.Chmod(fullPath, d.mode); err != nil {
			return fmt.Errorf("failed to set mode on %s: %w", d.path, err)
		}
	}

	// Create essential symlinks
	symlinks := []struct {
		target string
		link   string
	}{
		// /var/run -> /run
		{"/run", "/var/run"},
		// /var/lock -> /run/lock
		{"/run/lock", "/var/lock"},
	}

	for _, s := range symlinks {
		linkPath := filepath.Join(b.rootfsPath, s.link)
		// Remove existing if it's a directory
		if info, err := os.Lstat(linkPath); err == nil {
			if info.IsDir() {
				os.RemoveAll(linkPath)
			} else {
				os.Remove(linkPath)
			}
		}
		if err := os.Symlink(s.target, linkPath); err != nil {
			return fmt.Errorf("failed to create symlink %s -> %s: %w", s.link, s.target, err)
		}
	}

	log.Info("Created FHS directory skeleton", "rootfs", b.rootfsPath)
	return nil
}

// GenerateFstab generates /etc/fstab based on configuration
func (b *RootfsBuilder) GenerateFstab() error {
	fsType := b.config.System.Filesystem.Type
	if fsType == "" {
		fsType = "ext4"
	}

	// Determine mount options based on filesystem type
	var rootOpts string
	switch strings.ToLower(fsType) {
	case "ext4":
		rootOpts = "defaults,noatime"
	case "xfs":
		rootOpts = "defaults,noatime"
	case "btrfs":
		rootOpts = "defaults,noatime,compress=zstd"
	case "f2fs":
		rootOpts = "defaults,noatime"
	default:
		rootOpts = "defaults"
	}

	content := fmt.Sprintf(`# /etc/fstab: static file system information.
#
# Generated by Linux Distribution Factory
#
# <file system>  <mount point>  <type>  <options>         <dump>  <pass>

# Root filesystem
UUID=ROOT_UUID   /              %s     %s     0       1

# Pseudo filesystems
proc             /proc          proc    defaults          0       0
sysfs            /sys           sysfs   defaults          0       0
devtmpfs         /dev           devtmpfs mode=0755,nosuid 0       0
tmpfs            /dev/shm       tmpfs   defaults          0       0
devpts           /dev/pts       devpts  defaults          0       0
tmpfs            /run           tmpfs   defaults,mode=755 0       0
tmpfs            /tmp           tmpfs   defaults          0       0
`, fsType, rootOpts)

	// Add EFI partition if using UEFI boot
	if b.config.Core.Partitioning.Type == "gpt" {
		content += `
# EFI System Partition
UUID=EFI_UUID    /boot/efi      vfat    umask=0077        0       2
`
	}

	fstabPath := filepath.Join(b.rootfsPath, "etc", "fstab")
	if err := os.WriteFile(fstabPath, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write fstab: %w", err)
	}

	log.Info("Generated fstab", "path", fstabPath, "fstype", fsType)
	return nil
}

// GenerateOSRelease generates /etc/os-release
func (b *RootfsBuilder) GenerateOSRelease() error {
	// Generate a sanitized ID from distribution name
	id := strings.ToLower(b.distName)
	id = strings.ReplaceAll(id, " ", "-")
	id = strings.ReplaceAll(id, "_", "-")

	content := fmt.Sprintf(`NAME="%s"
VERSION="%s"
ID=%s
VERSION_ID=%s
PRETTY_NAME="%s %s"
HOME_URL="https://ldf.bitswalk.com"
BUG_REPORT_URL="https://github.com/bitswalk/ldf/issues"
BUILD_ID=ldf
`, b.distName, b.distVersion, id, b.distVersion, b.distName, b.distVersion)

	osReleasePath := filepath.Join(b.rootfsPath, "etc", "os-release")
	if err := os.WriteFile(osReleasePath, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write os-release: %w", err)
	}

	// Also create /usr/lib/os-release as the canonical location
	usrOsReleasePath := filepath.Join(b.rootfsPath, "usr", "lib", "os-release")
	if err := os.WriteFile(usrOsReleasePath, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write usr os-release: %w", err)
	}

	log.Info("Generated os-release", "name", b.distName, "version", b.distVersion)
	return nil
}

// GenerateHostname generates /etc/hostname
func (b *RootfsBuilder) GenerateHostname(hostname string) error {
	if hostname == "" {
		hostname = strings.ToLower(b.distName)
		hostname = strings.ReplaceAll(hostname, " ", "-")
	}

	hostnamePath := filepath.Join(b.rootfsPath, "etc", "hostname")
	if err := os.WriteFile(hostnamePath, []byte(hostname+"\n"), 0644); err != nil {
		return fmt.Errorf("failed to write hostname: %w", err)
	}

	// Also update /etc/hosts
	hosts := fmt.Sprintf(`127.0.0.1   localhost
127.0.1.1   %s
::1         localhost ip6-localhost ip6-loopback
ff02::1     ip6-allnodes
ff02::2     ip6-allrouters
`, hostname)

	hostsPath := filepath.Join(b.rootfsPath, "etc", "hosts")
	if err := os.WriteFile(hostsPath, []byte(hosts), 0644); err != nil {
		return fmt.Errorf("failed to write hosts: %w", err)
	}

	log.Info("Generated hostname", "hostname", hostname)
	return nil
}

// ConfigureNetworking sets up basic networking configuration
func (b *RootfsBuilder) ConfigureNetworking() error {
	// Create resolv.conf with common public DNS
	resolvConf := `# Generated by Linux Distribution Factory
# Replace with your preferred DNS servers
nameserver 1.1.1.1
nameserver 8.8.8.8
nameserver 9.9.9.9
`
	resolvPath := filepath.Join(b.rootfsPath, "etc", "resolv.conf")
	if err := os.WriteFile(resolvPath, []byte(resolvConf), 0644); err != nil {
		return fmt.Errorf("failed to write resolv.conf: %w", err)
	}

	// Create basic network interface configuration
	interfacesDir := filepath.Join(b.rootfsPath, "etc", "network")
	if err := os.MkdirAll(interfacesDir, 0755); err != nil {
		return fmt.Errorf("failed to create network dir: %w", err)
	}

	interfaces := `# Generated by Linux Distribution Factory
# Loopback interface
auto lo
iface lo inet loopback

# Primary network interface (DHCP)
auto eth0
iface eth0 inet dhcp
`
	interfacesPath := filepath.Join(interfacesDir, "interfaces")
	if err := os.WriteFile(interfacesPath, []byte(interfaces), 0644); err != nil {
		return fmt.Errorf("failed to write interfaces: %w", err)
	}

	log.Info("Configured basic networking")
	return nil
}

// ConfigureRootAccount sets up the root account
func (b *RootfsBuilder) ConfigureRootAccount() error {
	// Create /etc/passwd with root entry
	passwd := `root:x:0:0:root:/root:/bin/bash
nobody:x:65534:65534:Nobody:/nonexistent:/usr/sbin/nologin
`
	passwdPath := filepath.Join(b.rootfsPath, "etc", "passwd")
	if err := os.WriteFile(passwdPath, []byte(passwd), 0644); err != nil {
		return fmt.Errorf("failed to write passwd: %w", err)
	}

	// Create /etc/group
	group := `root:x:0:
wheel:x:10:
nobody:x:65534:
`
	groupPath := filepath.Join(b.rootfsPath, "etc", "group")
	if err := os.WriteFile(groupPath, []byte(group), 0644); err != nil {
		return fmt.Errorf("failed to write group: %w", err)
	}

	// Create /etc/shadow with locked root password
	shadow := `root:!:19000:0:99999:7:::
nobody:!:19000:0:99999:7:::
`
	shadowPath := filepath.Join(b.rootfsPath, "etc", "shadow")
	if err := os.WriteFile(shadowPath, []byte(shadow), 0600); err != nil {
		return fmt.Errorf("failed to write shadow: %w", err)
	}

	// Create /etc/gshadow
	gshadow := `root:::
wheel:::
nobody:::
`
	gshadowPath := filepath.Join(b.rootfsPath, "etc", "gshadow")
	if err := os.WriteFile(gshadowPath, []byte(gshadow), 0600); err != nil {
		return fmt.Errorf("failed to write gshadow: %w", err)
	}

	log.Info("Configured root account")
	return nil
}

// CreateDeviceNodes creates essential device nodes in /dev
func (b *RootfsBuilder) CreateDeviceNodes() error {
	devPath := filepath.Join(b.rootfsPath, "dev")

	dirs := []string{
		filepath.Join(devPath, "pts"),
		filepath.Join(devPath, "shm"),
	}

	for _, dir := range dirs {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return fmt.Errorf("failed to create dev subdirectory: %w", err)
		}
	}

	touch := func(path string, mode os.FileMode) error {
		f, err := os.OpenFile(path, os.O_CREATE|os.O_WRONLY, mode)
		if err != nil {
			return err
		}
		return f.Close()
	}

	if err := touch(filepath.Join(devPath, "console"), 0600); err != nil {
		log.Warn("Could not create /dev/console placeholder", "error", err)
	}
	if err := touch(filepath.Join(devPath, "null"), 0666); err != nil {
		log.Warn("Could not create /dev/null placeholder", "error", err)
	}

	log.Info("Created device node placeholders")
	return nil
}

// InstallKernel copies the compiled kernel to the rootfs
func (b *RootfsBuilder) InstallKernel(kernelOutputDir string) error {
	bootDir := filepath.Join(b.rootfsPath, "boot")
	if err := os.MkdirAll(bootDir, 0755); err != nil {
		return fmt.Errorf("failed to create boot directory: %w", err)
	}

	// Copy vmlinuz
	srcKernel := filepath.Join(kernelOutputDir, "boot", "vmlinuz")
	dstKernel := filepath.Join(bootDir, "vmlinuz")
	if err := copyFile(srcKernel, dstKernel); err != nil {
		return fmt.Errorf("failed to copy kernel: %w", err)
	}

	// Copy System.map
	srcSysmap := filepath.Join(kernelOutputDir, "boot", "System.map")
	dstSysmap := filepath.Join(bootDir, "System.map")
	if err := copyFile(srcSysmap, dstSysmap); err != nil {
		log.Warn("Could not copy System.map", "error", err)
	}

	// Copy kernel config
	srcConfig := filepath.Join(kernelOutputDir, "boot", "config")
	dstConfig := filepath.Join(bootDir, "config")
	if err := copyFile(srcConfig, dstConfig); err != nil {
		log.Warn("Could not copy kernel config", "error", err)
	}

	log.Info("Installed kernel to rootfs", "path", bootDir)
	return nil
}

// InstallModules copies the compiled kernel modules to the rootfs
func (b *RootfsBuilder) InstallModules(kernelOutputDir string) error {
	srcModules := filepath.Join(kernelOutputDir, "modules", "lib", "modules")
	dstModules := filepath.Join(b.rootfsPath, "lib", "modules")

	if _, err := os.Stat(srcModules); os.IsNotExist(err) {
		log.Warn("No kernel modules found to install")
		return nil
	}

	if err := copyDir(srcModules, dstModules); err != nil {
		return fmt.Errorf("failed to copy kernel modules: %w", err)
	}

	log.Info("Installed kernel modules to rootfs")
	return nil
}

// copyFile copies a single file preserving permissions
func copyFile(src, dst string) error {
	srcFile, err := os.Open(src)
	if err != nil {
		return err
	}
	defer srcFile.Close()

	srcInfo, err := srcFile.Stat()
	if err != nil {
		return err
	}

	dstFile, err := os.OpenFile(dst, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, srcInfo.Mode())
	if err != nil {
		return err
	}
	defer dstFile.Close()

	_, err = io.Copy(dstFile, srcFile)
	return err
}

// copyDir recursively copies a directory
func copyDir(src, dst string) error {
	return filepath.Walk(src, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		relPath, err := filepath.Rel(src, path)
		if err != nil {
			return err
		}
		dstPath := filepath.Join(dst, relPath)

		if info.IsDir() {
			return os.MkdirAll(dstPath, info.Mode())
		}

		// Handle symlinks
		if info.Mode()&os.ModeSymlink != 0 {
			link, err := os.Readlink(path)
			if err != nil {
				return err
			}
			return os.Symlink(link, dstPath)
		}

		// Copy regular file
		data, err := os.ReadFile(path)
		if err != nil {
			return err
		}
		return os.WriteFile(dstPath, data, info.Mode())
	})
}
